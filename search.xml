<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[搞个proxy暴露的一些问题]]></title>
    <url>%2Ftime-record%2F2017%2F09%2F08%2F%E6%90%9E%E4%B8%AAproxy%E6%9A%B4%E9%9C%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[参考链接在基于vue的webpack脚手架开发中使用了代理转发，结果浏览器发出的请求中不带cookie导致登录时总是session失效怎么办？vue2 前后端分离项目ajax跨域session问题解决Cookie not saved in browser最最开始的问题就不说了，直接讲主题 是这么个情况，我向后台发送请求，但是每次请求的id都不同之前也遇到过这个问题，是axios的问题但是其实不只是这样，其实set-cookie是指定了path的，所以path不同则读取不了至于在开发者工具里看不到cookie的原因大概是因为域名不一样，代理之后还要设置cookie转移才能看到]]></content>
  </entry>
  <entry>
    <title><![CDATA[【翻译】Service Worker，你是什么？]]></title>
    <url>%2Ftime-record%2F2017%2F08%2F12%2F%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Service%20Worker%EF%BC%8C%E4%BD%A0%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[原文 Service Worker, what are you ? 我：“Service Worker，你是什么？”Service Worker：“我是一个可编程网络代理。”我：“吓？” Service Worker听起来很酷炫，但是我并不了解他2015年七月，我在德州奥斯丁出席了一个JavaScript大会。台上的是Jake Archibald，我当时只知道他是一个讲了一些bathroom matter的有趣英国人。但是后来我才知道，他可是定制Service Worker规范的大人物。演讲地址台上他围绕着他对用户体验的感悟，介绍了一个叫做Service Worker的新东西，它可以让你的网站用起来和原生手机医用一样（这是我的理解）。这听起来很赞，我很希望可以把这个技术用在我的项目上，虽然刚接触它理解起来不容易…这不是一个库，不是一个新的HTML元素，又不是Javascript语法。阅读关于介绍Service Worker的文章总是被一些名词迷惑——例如“代理”和“缓存”。通过边理解边画图的方法，我终于对此有所理解，Service Worker是一个外星人，你可以邀请他住在你的浏览器里。听起来很奇怪？请听我解释。 在网络浏览器宇宙里，Service Worker是一个外星人 试想一下你的浏览器是计算机星系里的一个星球（像是地球）。这个星球里，人们用HTML, CSS, 和JavaScript等语言构成“网页社会”。如果你是网站开发者，从不同类型的元素到垃圾回收机制你都懂了，那你可能是这个星球的社会学家了。 这个星球发明了一种链接外部世界的方法，那就是超文本传输协议。这是从其他星系（服务器）请求资源的方法。有了这个方法我们的星球（浏览器）才能收集各种猫gif和发推。也是这个方法让这个星球变得有趣，并保持数百万住户。 把超文本传输协议（HTTP）说得很神奇，但实际上你要用HTTP连接其他星系需要为此铺设名为因特网的管道。尺寸和长度要看你给了网络供应商多少钱，以及你所在地区的基础设施。如果这条管道又窄又长，那获取资源的速度就相对慢些了。 问题来了，供应商不一定能保持我们星球的网络畅通，当浏览器不能连接这个管道，我们的星球就要回到过去了，回到那个恐龙横行的时代。 别慌！Service Worker 帮到你！Service Worker存在于管道和星球之间。你发送的请求交给了Service Worker，请求他帮忙，而不是直接传到其他星系。这（对我来说）感觉就像是UFO里面的外星人。 关于我们的新朋友Service Worker，你应该了解以下3件事 Service Worker 是你召唤的。除非你请求他，否则他不会出现。一旦你请求Service Worker的帮助，直到他觉得任务已经完成之前，他会一直存在。所以Service Worker没有.terminate()。 Service Worker 是存在于网页之外的。当你关闭一个浏览器窗口，通常一切进入不活动的状态。你不能下载视频或者浏览网页，但是！即使浏览器关闭了，Service Worker也可以在被需要时唤醒，然后在不被需要时消失，简直是奇迹！你（作为一个开发者）不用掌控Service Woker的生命周期。（这是我觉得他像外星人的原因） 之前提及到的，Service Worker 存在于页面之外，这意味着他不能接触到网页元素。你不能在Service Worker 访问window变量和document变量，也不能修改里面的DOM元素。所以Service Worker 可以帮我们做什么？1. 与缓存互动你可以请求Service Worker作为中间人检查事件收发，请求Service Worker在缓存里保存完整的资源。当缓存的项目被请求，Service Worker可以在缓存中请求这些数据而不用通过HTTP。这些资源被缓存了，浏览器就可以在网络不通的情况下展示内容。 2. 推送提醒得益于“Service Worker可以在浏览器窗口关闭时保持活动状态”这一奇迹，你可以实现类似推送提醒的功能。 3. 运行后台同步可以在浏览器窗口关闭时保持活动状态也意味着Service Worker可以在后台运作（如用户切换到其他标签时）。假如当浏览器离线时，你要发送一些文件，Service Worker 可以帮你在网络接通时上传。 如果你对Service Worker 是什么感到迷惑的话，希望这篇文章可以帮到你，想要开始写代码了？我推荐你看看Jake Archibald的offline-cookbook。 某译者的胡说八道到底bathroom matter是什么鬼啦（（]]></content>
      <categories>
        <category>翻译</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dva框架进坑记录]]></title>
    <url>%2Ftime-record%2F2017%2F08%2F09%2Fdva%E6%A1%86%E6%9E%B6%E8%BF%9B%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[以官方项目实战的例子，记录一些不容易懂的地方。部分摘抄官方文档或教程，部分自己理解，可能有错，望提醒 UI ComponentUI 组件（呈现组件），主要用于展示来源于prop的数据，无state，是无状态组件。 Model1234567891011import dva from 'dva';export default &#123; namespace: 'products', state: [], reducers: &#123; 'delete'(state, &#123; payload: id &#125;) &#123; return state.filter(item =&gt; item.id !== id); &#125;, &#125;,&#125;; model包含5个属性 namespacemodel 的命名空间，同时也是他在全局 state 上的属性，只能用字符串，不支持通过 . 的方式创建多层命名空间。 state初始值，优先级低于传给 dva() 的 opts.initialState。 reducers用于处理同步操作，唯一可以修改 state 的地方。由 action 触发。action是什么?Action 是一个普通 javascript 对象，它是改变 State 的唯一途径。action 必须带有 type 属性指明具体的行为，其它字段可以自定义。以下就是一个action1234&#123; type: 'products/delete', payload: id,&#125; dispatch是什么？dispatching function 是一个用于触发 action 的函数，action 是改变 State 的唯一途径，但是它只描述了一个行为，而 dipatch 可以看作是触发这个行为的方式，而 Reducer 则是描述如何改变数据的。以下是一个dispatch1234dispatch(&#123; type: 'products/delete', payload: id,&#125;); 最后是reducers格式(state, action) =&gt; newState effects用于处理异步操作和业务逻辑，不直接修改 state。由 action 触发，可以触发 action，可以和服务器交互，可以获取全局 state 的数据等等。 subscriptionssubscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。在 app.start() 时被执行，数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。 connect1234567891011121314151617181920212223import React from 'react';import &#123; connect &#125; from 'dva';import ProductList from '../components/ProductList';const Products = (&#123; dispatch, products &#125;) =&gt; &#123; function handleDelete(id) &#123; dispatch(&#123; type: 'products/delete', payload: id, &#125;); &#125; return ( &lt;div&gt; &lt;h2&gt;List of Products&lt;/h2&gt; &lt;ProductList onDelete=&#123;handleDelete&#125; products=&#123;products&#125; /&gt; &lt;/div&gt; );&#125;;// export default Products;export default connect((&#123; products &#125;) =&gt; (&#123; products,&#125;))(Products); 关于{ dispatch, products }在 dva 中，connect Model 的组件通过 props 可以访问到 dispatch，可以调用 Model 中的 Reducer 或者 Effects。 参考antd项目实战dva知识地图dva的数据流向dva API 拓展React-Redux 的用法Redux中的reducer到底是什么，以及它为什么叫reducer？]]></content>
  </entry>
  <entry>
    <title><![CDATA[my first post]]></title>
    <url>%2Ftime-record%2F2017%2F08%2F07%2Fmy-first-post%2F</url>
    <content type="text"><![CDATA[Now I’m listening Everything’s Alright.and I became sukasuka maniac those days.]]></content>
  </entry>
  <entry>
    <title><![CDATA[【翻译】Vue.js源码分析：计算属性如何工作]]></title>
    <url>%2Ftime-record%2F2017%2F08%2F03%2F%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Vue.js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[原文 Vue.js Internals: How computed properties work 这篇文章我们我会用很简单的方法来实现类似计算属性的效果，以此学习Vue.js的计算属性的运行机制。 这个例子只说明运行机制，不支持对象、数组、watching/unwatching等Vue.js已实现的一大堆优化 看完源代码带着我有限的理解写的这篇文章，可能会有一些错误，如发现错误，请联系我 JS的属性JS有Object.defineProperty方法，它能做的事情很多，但我们先关注这一点：123456789101112131415var person = &#123;&#125;;Object.defineProperty (person, 'age', &#123; get: function () &#123; console.log ("Getting the age"); return 25; &#125;&#125;);console.log ("The age is ", person.age);// 输出://// Getting the age// The age is 25 虽然看起来我们只是访问了对象的一个属性，但是其实我们是在运行一个函数。 基础的Vue.js ObservableVue.js有一个基础结构，它可以帮你把一个常规的对象转换成一个“被观察”的值，这个值就叫做“observable”。以下是一个实现响应式属性的例子12345678910111213141516171819202122232425262728function defineReactive (obj, key, val) &#123; Object.defineProperty (obj, key, &#123; get: function () &#123; return val; &#125;, set: function (newValue) &#123; val = newValue; &#125; &#125;)&#125;;// 创建对象var person = &#123;&#125;;// 添加两个响应式属性defineReactive (person, 'age', 25);defineReactive (person, 'country', 'Brazil');// 现在你可以使用这两个属性if (person.age &lt; 18) &#123; return 'minor';&#125;else &#123; return 'adult';&#125;// 也可以给他们赋值person.country = 'Russia'; 有趣的是，25和Brazil仍是闭包变量val，当你赋值时，它们的值也会被修改。这个值不是存在于person.country，而是存在于getter函数闭包。 定义一个计算属性创建一个计算属性函数defineComputed1234567891011121314151617181920defineComputed ( person, // the object to create computed property on 'status', // the name of the computed property function () &#123; // the function which actually computes the property console.log ("status getter called") if (person.age &lt; 18) &#123; return 'minor'; &#125; else &#123; return 'adult'; &#125; &#125;, function (newValue) &#123; // called when the computed value is updated console.log ("status has changed to", newValue) &#125;&#125;);// We can use the computed property like a regular propertyconsole.log ("The person's status is: ", person.status); 以下是defineComputed的简单实现。这个函数支持调用计算函数，但是暂不支持updateCallback1234567891011function defineComputed (obj, key, computeFunc, updateCallback) &#123; Object.defineProperty (obj, key, &#123; get: function () &#123; // call the compute function and return the value return computeFunc (); &#125;, set: function () &#123; // don't do anything. can't set computed funcs &#125; &#125;)&#125; 这个函数有两个问题 每当属性被访问，计算函数都会运行 这个函数不知道何时应该更新1234567// 我们希望达到这个效果person.age = 17;// console: status has changed to: minorperson.age = 22;// console: status has changed to: adult 添加一个依赖跟踪器创建一个全局变量Dep123var Dep = &#123; target: null&#125;; 这就是依赖跟踪器，现在我们把这个关键点融入defineComputed12345678910111213141516function defineComputed (obj, key, computeFunc, updateCallback) &#123; var onDependencyUpdated = function () &#123; // TODO &#125; Object.defineProperty (obj, key, &#123; get: function () &#123; // Set the dependency target as this function Dep.target = onDependencyUpdated; var value = computeFunc (); Dep.target = null; &#125;, set: function () &#123; // don't do anything. can't set computed funcs &#125; &#125;)&#125; 我们现在回到定义响应式对象的步骤1234567891011121314151617181920212223242526function defineReactive (obj, key, val) &#123; // all computed properties that depend on this var deps = []; Object.defineProperty (obj, key, &#123; get: function () &#123; // 检查是否有计算属性调用这个getter // 顺便检查这个以来是否存在 if (Dep.target &amp;&amp; ) &#123; // 添加依赖 deps.push (target); &#125; return val; &#125;, set: function (newValue) &#123; val = newValue; // 通知所有依赖这个值的计算属性 deps.forEach ((changeFunction) =&gt; &#123; // 请求重新计算 changeFunction (); &#125;); &#125; &#125;)&#125;; 我们在计算属性的定义里更新onDependencyUpdated函数，用以触发更新回调函数。12345var onDependencyUpdated = function () &#123; // compute the value again var value = computeFunc (); updateCallback (value);&#125; 综合上述代码从新看回我们之前定义的计算属性person.status1234567891011121314151617person.age = 22;defineComputed ( person, 'status', function () &#123; // compute function if (person.age &gt; 18) &#123; return 'adult'; &#125; &#125;, function (newValue) &#123; console.log ("status has changed to", newValue) &#125;&#125;);console.log ("Status is ", person.status); 第一步：person.status被访问，触发了get()函数，Dep.target现在是onDependencyUpdated 第二步：（计算属性的get()函数第二行）调用了计算函数computeFunc,而这个计算函数又调用了age属性，也就是触发了age属性的get() 第三步：看回age属性的get()，如果Dep.target当前是有值的话，这个值就会被push到依赖列表（所以现在onDependencyUpdated就在age属性的依赖列表里咯），之后Dep.target会被赋值为null 第四步：现在，每当person.age被赋值，都会通知person.status啦 某译者的胡说八道如作者所说这个例子只是简化版，像官网说计算属性是基于它们的依赖进行缓存的这点没有表现出来，所以更多细节请研究Vue的源码但是读了这篇文章我们可以知道计算属性更新是依赖data的属性通知的，所以必须调用了data的属性才会“重新计算”，否则永远不会更新这就是为什么官网说 如果计算函数里面调用了多个属性，那么这些属性更新时都会通知这个计算函数。 其他参考 Vue 响应式原理探析]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
</search>
